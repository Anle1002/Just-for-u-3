<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Magic Hand - Synchronized Rotation</title>
    
    <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
    <script src="https://www.youtube.com/iframe_api"></script>

    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: sans-serif; }
        #bg-image { position: fixed; inset: 0; background: url('https://images.unsplash.com/photo-1543589077-47d81606c1bf?q=80&w=2070') center/cover; filter: brightness(0.1); z-index: -1; }
        #start-overlay { position: fixed; inset: 0; background: rgba(0,0,0,0.9); display: flex; align-items: center; justify-content: center; z-index: 200; }
        #start-btn { padding: 15px 45px; border: 2px solid #fff; background: none; color: #fff; cursor: pointer; font-size: 1.2rem; font-weight: bold; letter-spacing: 2px; }
        #video-container { position: absolute; bottom: 20px; right: 20px; width: 160px; height: 120px; border-radius: 8px; overflow: hidden; transform: scaleX(-1); border: 1px solid #333; }
        video { width: 100%; height: 100%; object-fit: cover; }
        #yt-player-container { position: absolute; top: -1000px; left: -1000px; }
    </style>
</head>
<body>

    <div id="bg-image"></div>
    <div id="yt-player-container"><div id="player"></div></div>
    <div id="start-overlay"><button id="start-btn">BẮT ĐẦU</button></div>
    <div id="video-container"><video id="webcam" autoplay playsinline></video></div>

    <script>
        const PARTICLE_COUNT = 25000;
        let scene, camera, renderer, particles, snowflake, ytPlayer;
        let handTracker, videoElement, mainGroup;
        let assemblyFactor = 0, targetAssembly = 0;
        let extraImages = [];

        const driveIDs = [
            '1Sic5fMu3E2-WVNhflfmSCIlzphiPxFLh', '1ikC2YuAgDxVibcxShRcDrZEWGsq8R5Xb',
            '12ZkIlUC-6m8exE4Xkw_wdYh_ZbjcUa1S', '13zH-VZG0_IULrhFDphyMLc9iPKRX7dCz',
            '11dlK8KYP-fvt4Il91nwv3Ah7FEg0usl3', '1m5PvE-UdyxEtYftu1T9nQBk8BT6Hpsz5',
            '1t4P1QXc5fvkGFX2IBce4zBgkseMQRWJY', '11EOid82XxzbPSLRY6LkzT_mwF8G6fq5L'
        ];

        function onYouTubeIframeAPIReady() {
            ytPlayer = new YT.Player('player', {
                height: '0', width: '0', videoId: '6ag__ntUafU',
                playerVars: { 'autoplay': 1, 'controls': 0, 'loop': 1, 'playlist': '6ag__ntUafU' },
                events: { 'onReady': (e) => e.target.mute() }
            });
        }

        document.getElementById('start-btn').onclick = function() {
            document.getElementById('start-overlay').style.display = 'none';
            if (ytPlayer) { ytPlayer.unMute(); ytPlayer.setVolume(50); ytPlayer.playVideo(); }
            init();
        };

        async function init() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 8;

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);
            
            mainGroup = new THREE.Group(); // Tạo Group để quản lý xoay chung
            scene.add(mainGroup);

            createColorfulParticles();
            createOrganizedImages();
            createRealisticSnowflake();
            
            await setupMediaPipe();
            gsap.ticker.add(render);
        }

        function createOrganizedImages() {
            const loader = new THREE.TextureLoader();
            loader.setCrossOrigin('anonymous');
            
            driveIDs.forEach((id, i) => {
                const url = `https://lh3.googleusercontent.com/d/${id}`;
                const texture = loader.load(url);
                const material = new THREE.SpriteMaterial({ map: texture, transparent: true, opacity: 0 });
                const sprite = new THREE.Sprite(material);
                
                const angle = (i / driveIDs.length) * Math.PI * 2;
                const radius = 5.5;
                
                sprite.userData.chaosPos = new THREE.Vector3(
                    Math.cos(angle) * radius,
                    (Math.random() - 0.5) * 2,
                    Math.sin(angle) * radius
                );
                sprite.userData.treePos = new THREE.Vector3(0, 0, 0);
                sprite.scale.set(1.5, 1.5, 1);
                
                mainGroup.add(sprite); // Thêm vào mainGroup để xoay cùng hạt
                extraImages.push(sprite);
            });
        }

        function createColorfulParticles() {
            const geo = new THREE.BufferGeometry();
            const pos = new Float32Array(PARTICLE_COUNT * 3), tar = new Float32Array(PARTICLE_COUNT * 3), chos = new Float32Array(PARTICLE_COUNT * 3), cols = new Float32Array(PARTICLE_COUNT * 3);
            const palette = [0xf1c40f, 0x2ecc71, 0xffffff, 0xe74c3c, 0x333333];

            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const h = Math.random() * 6 - 3; 
                const radTree = ((3 - h) / 6) * 2.3; 
                const angTree = Math.random() * Math.PI * 2;
                tar[i*3] = Math.cos(angTree) * radTree; tar[i*3+1] = h; tar[i*3+2] = Math.sin(angTree) * radTree;

                const angle = Math.random() * Math.PI * 2;
                const radius = Math.pow(Math.random(), 0.5) * 12;
                chos[i*3] = Math.cos(angle) * radius; chos[i*3+1] = (Math.random() - 0.5) * 6; chos[i*3+2] = Math.sin(angle) * radius;

                const c = new THREE.Color(palette[Math.floor(Math.random() * palette.length)]);
                cols[i*3] = c.r; cols[i*3+1] = c.g; cols[i*3+2] = c.b;
            }
            geo.setAttribute('position', new THREE.BufferAttribute(pos, 3));
            geo.setAttribute('target', new THREE.BufferAttribute(tar, 3));
            geo.setAttribute('chaos', new THREE.BufferAttribute(chos, 3));
            geo.setAttribute('color', new THREE.BufferAttribute(cols, 3));
            
            const canvas = document.createElement('canvas');
            canvas.width = 64; canvas.height = 64;
            const ctx = canvas.getContext('2d');
            ctx.beginPath(); ctx.arc(32, 32, 30, 0, Math.PI * 2);
            ctx.fillStyle = '#ffffff'; ctx.fill();

            particles = new THREE.Points(geo, new THREE.PointsMaterial({ size: 0.04, vertexColors: true, map: new THREE.CanvasTexture(canvas), transparent: true, opacity: 0.8 }));
            mainGroup.add(particles); // Thêm vào mainGroup
        }

        function createRealisticSnowflake() {
            snowflake = new THREE.Group();
            const mat = new THREE.MeshBasicMaterial({ color: 0xffffff, side: THREE.DoubleSide, transparent: true, opacity: 0 });
            const createBranch = () => {
                const shape = new THREE.Shape();
                shape.moveTo(0,0); shape.lineTo(0.04,0.1); shape.lineTo(0.01,0.7); shape.lineTo(0,0.75); shape.lineTo(-0.01,0.7); shape.lineTo(-0.04,0.1);
                const m = new THREE.Mesh(new THREE.ShapeGeometry(shape), mat);
                for(let i=0; i<3; i++) {
                    const s = m.clone(); s.scale.set(0.35,0.35,1); s.position.set(0,0.2+i*0.2,0); s.rotation.z=Math.PI/4;
                    const s2 = s.clone(); s2.rotation.z=-Math.PI/4; m.add(s,s2);
                }
                return m;
            };
            for (let i = 0; i < 6; i++) { const b = createBranch(); b.rotation.z = (i*Math.PI*2)/6; snowflake.add(b); }
            snowflake.position.y = 3.3; 
            scene.add(snowflake); // Snowflake không thuộc mainGroup để nó đứng yên ở đỉnh cây
        }

        async function setupMediaPipe() {
            videoElement = document.getElementById('webcam');
            handTracker = new Hands({ locateFile: (f) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${f}` });
            handTracker.setOptions({ maxNumHands: 1, modelComplexity: 1 });
            handTracker.onResults(results => {
                if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                    const lm = results.multiHandLandmarks[0];
                    targetAssembly = (lm[8].y > lm[6].y && lm[12].y > lm[10].y) ? 1 : 0;
                } else { targetAssembly = 0; }
            });
            new Camera(videoElement, { onFrame: async () => await handTracker.send({ image: videoElement }), width: 640, height: 480 }).start();
        }

        function render() {
            assemblyFactor = THREE.MathUtils.lerp(assemblyFactor, targetAssembly, 0.07);
            if(ytPlayer && ytPlayer.setVolume && ytPlayer.getPlayerState() === 1) {
                ytPlayer.setVolume(20 + assemblyFactor * 70);
            }

            const p = particles.geometry.attributes.position, t = particles.geometry.attributes.target, c = particles.geometry.attributes.chaos;
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const ix=i*3, iy=i*3+1, iz=i*3+2;
                p.array[ix] = THREE.MathUtils.lerp(c.array[ix], t.array[ix], assemblyFactor);
                p.array[iy] = THREE.MathUtils.lerp(c.array[iy], t.array[iy], assemblyFactor);
                p.array[iz] = THREE.MathUtils.lerp(c.array[iz], t.array[iz], assemblyFactor);
            }
            p.needsUpdate = true;

            // XOAY TOÀN BỘ NHÓM (Hạt + Ảnh)
            mainGroup.rotation.y += 0.005;

            extraImages.forEach(sprite => {
                sprite.position.lerpVectors(sprite.userData.chaosPos, sprite.userData.treePos, assemblyFactor);
                // Ảnh hiện rõ khi xòe tay
                sprite.material.opacity = 1 - assemblyFactor;
            });

            if(snowflake) {
                snowflake.scale.setScalar(assemblyFactor * 1.5);
                snowflake.rotation.y += 0.03;
                snowflake.traverse(child => { if(child.material) child.material.opacity = assemblyFactor; });
            }
            renderer.render(scene, camera);
        }
    </script>
</body>
</html>