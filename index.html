<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Magic Hand - Perfect Billboard Photos</title>

    <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
    <script src="https://www.youtube.com/iframe_api"></script>

    <!-- Font đẹp, hỗ trợ tiếng Việt + font tình cảm cho OK text -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Be+Vietnam+Pro:wght@700;800;900&family=Dancing+Script:wght@600;700&display=swap" rel="stylesheet">

    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: sans-serif; }

        /* === NỀN GIÁNG SINH (áp dụng cho mọi cử chỉ) === */
        #bg-image {
            position: fixed;
            inset: 0;
            background: url('https://images.unsplash.com/photo-1546706872-8cf9f9cd2d55?q=80&w=2070') center/cover;
            filter: brightness(0.28) saturate(1.15);
            z-index: -2;
        }
        #bg-overlay {
            position: fixed;
            inset: 0;
            background:
                radial-gradient(ellipse at center, rgba(0,0,0,0.15) 0%, rgba(0,0,0,0.70) 70%, rgba(0,0,0,0.88) 100%);
            z-index: -1;
            pointer-events: none;
        }

        /* === TUYẾT RƠI (BÔNG TUYẾT THẬT - CANVAS) áp dụng cho mọi cử chỉ === */
        #snow-canvas{
            position: fixed;
            inset: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 120;
        }

        #start-overlay { position: fixed; inset: 0; background: rgba(0,0,0,0.9); display: flex; align-items: center; justify-content: center; z-index: 200; }
        #start-btn {
            padding: 20px 40px;
            border: 3px solid #ff4d4d;
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            cursor: pointer;
            font-size: 1.5rem;
            font-weight: bold;
            border-radius: 50px;
            transition: all 0.3s ease;
            box-shadow: 0 0 20px rgba(255, 77, 77, 0.5);
        }
        #start-btn:hover { background: #ff4d4d; transform: scale(1.1); }
        #video-container { position: absolute; bottom: 20px; right: 20px; width: 160px; height: 120px; border-radius: 8px; overflow: hidden; transform: scaleX(-1); border: 1px solid #333; z-index: 210; }
        video { width: 100%; height: 100%; object-fit: cover; }

        /* === TEXT CHỈ HIỆN KHI Ở CHẾ ĐỘ CÂY THÔNG === */
        #greeting {
            position: fixed;
            top: 18px;
            left: 0;
            width: 100%;
            text-align: center;

            font-family: "Be Vietnam Pro", system-ui, -apple-system, "Segoe UI", sans-serif;
            font-size: clamp(22px, 3.2vw, 46px);
            font-weight: 900;
            letter-spacing: 0.6px;

            background: linear-gradient(
                110deg,
                rgba(255, 215, 0, 0.35) 0%,
                rgba(255, 239, 170, 1) 18%,
                rgba(255, 215, 0, 1) 40%,
                rgba(255, 250, 220, 1) 52%,
                rgba(255, 215, 0, 1) 70%,
                rgba(255, 215, 0, 0.35) 100%
            );
            background-size: 260% 100%;
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;

            text-shadow:
                0 0 10px rgba(255, 215, 0, 0.30),
                0 0 22px rgba(255, 215, 0, 0.18),
                0 2px 0 rgba(0, 0, 0, 0.35);

            z-index: 160;
            pointer-events: none;
            display: none;

            animation: textShimmer 2.2s linear infinite, textTwinkle 1.6s ease-in-out infinite;
        }

        #greeting::after {
            content: "";
            position: absolute;
            inset: -10px 0 -10px 0;
            pointer-events: none;
            background:
                radial-gradient(circle at 12% 45%, rgba(255,255,255,0.65) 0 2px, transparent 3px),
                radial-gradient(circle at 28% 25%, rgba(255,255,255,0.55) 0 1.6px, transparent 3px),
                radial-gradient(circle at 44% 55%, rgba(255,255,255,0.60) 0 1.8px, transparent 3px),
                radial-gradient(circle at 61% 30%, rgba(255,255,255,0.50) 0 1.5px, transparent 3px),
                radial-gradient(circle at 73% 60%, rgba(255,255,255,0.62) 0 1.9px, transparent 3px),
                radial-gradient(circle at 88% 40%, rgba(255,255,255,0.55) 0 1.6px, transparent 3px);
            opacity: 0.0;
            filter: blur(0.2px);
            animation: sparkleDust 1.25s ease-in-out infinite;
        }

        #greeting .heart{
            display: inline-block;
            margin-left: 10px;
            font-size: 0.95em;
            line-height: 1;
            filter: drop-shadow(0 0 10px rgba(255, 40, 40, 0.45));
            animation: heartBeat 1.2s ease-in-out infinite;
        }

        @keyframes textShimmer {
            0%   { background-position: 0% 50%; }
            100% { background-position: 260% 50%; }
        }
        @keyframes textTwinkle {
            0%, 100% { filter: drop-shadow(0 0 0 rgba(255,215,0,0)); transform: translateY(0); }
            50% { filter: drop-shadow(0 0 10px rgba(255,215,0,0.20)); transform: translateY(-0.5px); }
        }
        @keyframes sparkleDust {
            0%, 100% { opacity: 0.05; transform: translateY(0); }
            50%      { opacity: 0.35; transform: translateY(-1px); }
        }
        @keyframes heartBeat{
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.18); }
        }

        /* ===================== OK LOVE TEXT (hiện khi làm ký hiệu OK) ===================== */
        #ok-love{
            position: fixed;
            top: 18px;
            left: 50%;
            transform: translateX(-50%);
            width: min(980px, calc(100% - 28px));
            z-index: 185;
            pointer-events: none;

            display: none;
            opacity: 0;

            padding: 16px 18px 14px;
            border-radius: 18px;
            background: rgba(0,0,0,0.28);
            backdrop-filter: blur(6px);
            box-shadow:
                0 18px 40px rgba(0,0,0,0.35),
                0 0 28px rgba(255, 215, 0, 0.10);
        }

        #ok-love .ok-line{
            text-align: center;
            color: transparent;
            -webkit-background-clip: text;
            background-clip: text;
            background-image: linear-gradient(
                105deg,
                rgba(255,215,0,0.40) 0%,
                rgba(255,245,190,1) 18%,
                rgba(255,215,0,1) 42%,
                rgba(255,255,255,1) 52%,
                rgba(255,215,0,1) 70%,
                rgba(255,215,0,0.40) 100%
            );
            background-size: 260% 100%;

            text-shadow:
                0 0 12px rgba(255, 215, 0, 0.16),
                0 2px 0 rgba(0,0,0,0.35);

            filter: drop-shadow(0 0 10px rgba(255, 215, 0, 0.08));
        }

        #ok-love .ok-title{
            font-family: "Be Vietnam Pro", system-ui, -apple-system, "Segoe UI", sans-serif;
            font-weight: 900;
            letter-spacing: 0.6px;
            font-size: clamp(18px, 2.2vw, 34px);
            margin-bottom: 8px;
        }

        #ok-love .ok-body{
            font-family: "Dancing Script", cursive;
            font-weight: 700;
            font-size: clamp(18px, 2.1vw, 28px);
            line-height: 1.25;
            padding: 0 6px;
        }

        #ok-love .ok-char{
            display: inline-block;
            opacity: 0;
            transform: translateY(8px);
            will-change: transform, opacity;
        }
        #ok-love .ok-space{
            display: inline-block;
            width: 0.28em;
        }

        #ok-love .ok-cursor{
            text-align: center;
            margin-top: 6px;
            font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
            color: rgba(255,255,255,0.65);
            opacity: 0.75;
            animation: okBlink 0.8s steps(1) infinite;
        }
        @keyframes okBlink{ 50%{ opacity: 0; } }
    </style>
</head>
<body>

    <div id="bg-image"></div>
    <div id="bg-overlay"></div>

    <canvas id="snow-canvas"></canvas>

    <div id="greeting">Chúc em yêu giáng sinh vui vẻ <span class="heart">❤️</span></div>

    <!-- OK LOVE TEXT (hiện khi làm ký hiệu OK) -->
    <div id="ok-love">
        <div class="ok-line ok-title" id="ok-line-1"></div>
        <div class="ok-line ok-body" id="ok-line-2"></div>
        <div class="ok-cursor" id="ok-cursor">|</div>
    </div>

    <div id="yt-player-container"><div id="player"></div></div>
    <div id="start-overlay"><button id="start-btn">Quà giáng sinh của bé nè ^^</button></div>
    <div id="video-container"><video id="webcam" autoplay playsinline></video></div>

    <script>
        const PARTICLE_COUNT = 35000;
        const TREE_Y_OFFSET = -0.85;

        let scene, camera, renderer, particles, snowflakeGroup, ytPlayer;
        let snowflakeSparkles = [], snowflakeGlow;
        let starMaterial;

        let greetingEl;

        let lightParticles, lightMaterial;
        let lightIndices = [];

        let leafSparkles, leafSparkleMat;
        let leafSparkleIndices = [];
        let leafSparkleBaseCols, leafSparkleCols, leafSparklePhase, leafSparkleSpeed;

        let trunkParticles, trunkMaterial, trunkIndices = [];
        let trunkCoreParticles, trunkCoreMaterial, trunkCoreIndices = [];

        let handTracker, videoElement, mainGroup;
        let fHeart = 0, fGalaxy = 0, fOk = 0;
        let tHeart = 0, tGalaxy = 0, tOk = 0;
        let photoPairs = [];

        // OK LOVE DOM
        let okLoveEl, okLine1El, okLine2El, okCursorEl;
        let okTextTL = null;
        let okTextShown = false;

        const driveIDs = ['1Sic5fMu3E2-WVNhflfmSCIlzphiPxFLh', '1ikC2YuAgDxVibcxShRcDrZEWGsq8R5Xb', '12ZkIlUC-6m8exE4Xkw_wdYh_ZbjcUa1S', '13zH-VZG0_IULrhFDphyMLc9iPKRX7dCz', '11dlK8KYP-fvt4Il91nwv3Ah7FEg0usl3', '1m5PvE-UdyxEtYftu1T9nQBk8BT6Hpsz5', '1t4P1QXc5fvkGFX2IBce4zBgkseMQRWJY', '11EOid82XxzbPSLRY6LkzT_mwF8G6fq5L'];

        // ====== SNOW (BÔNG TUYẾT THẬT) ======
        let snowCanvas, snowCtx;
        let snowFlakes = [];
        let snowLastT = 0;
        let snowW = 0, snowH = 0;

        function resizeSnow() {
            if (!snowCanvas) return;
            const dpr = Math.min(window.devicePixelRatio || 1, 2);
            snowW = window.innerWidth;
            snowH = window.innerHeight;
            snowCanvas.width = Math.floor(snowW * dpr);
            snowCanvas.height = Math.floor(snowH * dpr);
            snowCanvas.style.width = snowW + "px";
            snowCanvas.style.height = snowH + "px";
            snowCtx.setTransform(dpr, 0, 0, dpr, 0, 0);
        }

        function makeSnowflakes() {
            // (đã giảm mạnh để đỡ lag)
            const base = Math.floor((window.innerWidth * window.innerHeight) / 13000);
            const count = Math.max(40, Math.min(base, 110));

            snowFlakes = [];
            for (let i = 0; i < count; i++) {
                const size = 4 + Math.random() * 9;
                snowFlakes.push({
                    x: Math.random() * snowW,
                    y: Math.random() * snowH,
                    r: size,
                    vy: 18 + Math.random() * 55,
                    vx: -10 + Math.random() * 20,
                    drift: 0.6 + Math.random() * 1.2,
                    rot: Math.random() * Math.PI * 2,
                    vrot: (-0.9 + Math.random() * 1.8) * 0.7,
                    alpha: 0.35 + Math.random() * 0.55,
                    twPhase: Math.random() * Math.PI * 2,
                    twSpeed: 1.4 + Math.random() * 2.4
                });
            }
        }

        function drawOneSnowflake(ctx, r) {
            ctx.lineCap = "round";
            ctx.lineJoin = "round";

            const arms = 6;
            const armLen = r * 1.25;
            const branch1 = r * 0.45;
            const branch2 = r * 0.75;

            for (let i = 0; i < arms; i++) {
                ctx.rotate((Math.PI * 2) / arms);

                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.lineTo(0, -armLen);
                ctx.stroke();

                ctx.beginPath();
                ctx.moveTo(0, -branch1);
                ctx.lineTo(-r * 0.35, -branch1 - r * 0.20);
                ctx.moveTo(0, -branch1);
                ctx.lineTo(r * 0.35, -branch1 - r * 0.20);
                ctx.stroke();

                ctx.beginPath();
                ctx.moveTo(0, -branch2);
                ctx.lineTo(-r * 0.28, -branch2 - r * 0.18);
                ctx.moveTo(0, -branch2);
                ctx.lineTo(r * 0.28, -branch2 - r * 0.18);
                ctx.stroke();
            }

            ctx.beginPath();
            ctx.arc(0, 0, r * 0.18, 0, Math.PI * 2);
            ctx.fill();
        }

        function renderSnow(nowMs) {
            if (!snowCtx) return;

            if (!snowLastT) snowLastT = nowMs;
            const dt = Math.min((nowMs - snowLastT) / 1000, 0.033);
            snowLastT = nowMs;

            const t = nowMs * 0.001;
            snowCtx.clearRect(0, 0, snowW, snowH);

            for (let i = 0; i < snowFlakes.length; i++) {
                const f = snowFlakes[i];

                f.y += f.vy * dt;
                f.x += (f.vx + Math.sin(t * 0.9 + f.twPhase) * 18 * f.drift) * dt;
                f.rot += f.vrot * dt;

                if (f.y > snowH + 20) {
                    f.y = -20 - Math.random() * 80;
                    f.x = Math.random() * snowW;
                }
                if (f.x < -40) f.x = snowW + 40;
                if (f.x > snowW + 40) f.x = -40;

                const tw = 0.55 + 0.45 * Math.sin(t * f.twSpeed + f.twPhase);
                const a = f.alpha * (0.65 + 0.35 * tw);

                snowCtx.save();
                snowCtx.translate(f.x, f.y);
                snowCtx.rotate(f.rot);

                snowCtx.globalAlpha = a;
                snowCtx.shadowColor = "rgba(255,255,255,0.55)";
                snowCtx.shadowBlur = 10;

                snowCtx.strokeStyle = "rgba(255,255,255,0.92)";
                snowCtx.lineWidth = Math.max(0.8, f.r * 0.12);
                snowCtx.fillStyle = "rgba(255,255,255,0.95)";

                drawOneSnowflake(snowCtx, f.r);
                snowCtx.restore();
            }
        }

        function initSnowSystem() {
            snowCanvas = document.getElementById("snow-canvas");
            snowCtx = snowCanvas.getContext("2d");

            resizeSnow();
            makeSnowflakes();

            window.addEventListener("resize", () => {
                resizeSnow();
                makeSnowflakes();
            }, { passive: true });
        }
        // ====== END SNOW ======

        function onYouTubeIframeAPIReady() {
            ytPlayer = new YT.Player('player', { height: '0', width: '0', videoId: '6ag__ntUafU', playerVars: { 'autoplay': 1, 'controls': 0, 'loop': 1, 'playlist': '6ag__ntUafU' }});
        }

        document.getElementById('start-btn').onclick = function() {
            document.getElementById('start-overlay').style.display = 'none';
            if (ytPlayer && ytPlayer.playVideo) { ytPlayer.unMute(); ytPlayer.playVideo(); }
            init();
        };

        async function init() {
            scene = new THREE.Scene();
            greetingEl = document.getElementById('greeting');

            // OK LOVE DOM
            okLoveEl = document.getElementById("ok-love");
            okLine1El = document.getElementById("ok-line-1");
            okLine2El = document.getElementById("ok-line-2");
            okCursorEl = document.getElementById("ok-cursor");

            initSnowSystem();

            const amb = new THREE.AmbientLight(0xffffff, 0.62);
            scene.add(amb);
            const dir = new THREE.DirectionalLight(0xffffff, 1.05);
            dir.position.set(7, 10, 10);
            scene.add(dir);

            const aspect = window.innerWidth / window.innerHeight;
            const d = 8;
            camera = new THREE.OrthographicCamera(-d * aspect, d * aspect, d, -d, 0.1, 1000);
            camera.position.z = 25;

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);

            renderer.domElement.style.position = "fixed";
            renderer.domElement.style.inset = "0";
            renderer.domElement.style.zIndex = "50";

            document.body.appendChild(renderer.domElement);

            mainGroup = new THREE.Group();
            scene.add(mainGroup);

            createParticles();
            createPhotos();
            createUltimateSnowflake();

            await setupMediaPipe();
            gsap.ticker.add(render);
        }

        function createPhotos() {
            const loader = new THREE.TextureLoader();
            loader.setCrossOrigin('anonymous');
            driveIDs.forEach((id, i) => {
                const group = new THREE.Group();
                const proxyUrl = `https://images.weserv.nl/?url=drive.google.com/uc?id=${id}`;

                const photoMat = new THREE.MeshBasicMaterial({
                    map: loader.load(proxyUrl),
                    transparent: true,
                    opacity: 0,
                    depthWrite: false
                });
                const borderMat = new THREE.MeshBasicMaterial({
                    color: 0xFFD700,
                    transparent: true,
                    opacity: 0,
                    depthWrite: false
                });

                const border = new THREE.Mesh(new THREE.PlaneGeometry(1.6, 1.6), borderMat);
                const photo = new THREE.Mesh(new THREE.PlaneGeometry(1.5, 1.5), photoMat);
                photo.position.z = 0.01;
                group.add(border); group.add(photo);

                const angle = (i / 8) * Math.PI * 4;
                const dist = 5.5 + (i * 0.7);
                group.userData = {
                    posGalaxy: new THREE.Vector3(Math.cos(angle)*dist, (Math.random()-0.5)*5, Math.sin(angle)*dist),
                    posHeart: new THREE.Vector3(((i % 4) - 1.5) * 1.8, (Math.floor(i / 4) - 0.5) * -1.8, 0)
                };
                mainGroup.add(group);
                photoPairs.push({ group, borderMat, photoMat });
            });
        }

        function createLights() {
            if (!lightIndices.length) return;

            const baseGeo = particles.geometry;
            const s = baseGeo.attributes.tS;

            const lGeo = new THREE.BufferGeometry();
            const lPos = new Float32Array(lightIndices.length * 3);
            const lCols = new Float32Array(lightIndices.length * 3);

            const lightPalette = [0xffffff, 0xffd700, 0xff3b30, 0x34c759, 0x5ac8fa];

            for (let j = 0; j < lightIndices.length; j++) {
                const i = lightIndices[j];
                const ix = i * 3;

                lPos[j*3]   = s.array[ix];
                lPos[j*3+1] = s.array[ix+1];
                lPos[j*3+2] = s.array[ix+2];

                const c = new THREE.Color(lightPalette[Math.floor(Math.random() * lightPalette.length)]);
                lCols[j*3]   = c.r;
                lCols[j*3+1] = c.g;
                lCols[j*3+2] = c.b;
            }

            lGeo.setAttribute('position', new THREE.BufferAttribute(lPos, 3));
            lGeo.setAttribute('color', new THREE.BufferAttribute(lCols, 3));

            lightMaterial = new THREE.PointsMaterial({
                size: 0.42,
                vertexColors: true,
                transparent: true,
                opacity: 0.85,
                depthWrite: false,
                blending: THREE.AdditiveBlending
            });

            lightParticles = new THREE.Points(lGeo, lightMaterial);
            lightParticles.renderOrder = 8;
            mainGroup.add(lightParticles);
        }

        function createLeafSparkles() {
            if (!leafSparkleIndices.length) return;

            const baseGeo = particles.geometry;
            const s = baseGeo.attributes.tS;

            const spGeo = new THREE.BufferGeometry();
            const spPos = new Float32Array(leafSparkleIndices.length * 3);
            const spCols = new Float32Array(leafSparkleIndices.length * 3);
            const baseCols = new Float32Array(leafSparkleIndices.length * 3);
            const phase = new Float32Array(leafSparkleIndices.length);
            const speed = new Float32Array(leafSparkleIndices.length);

            const sparklePalette = [0xffffff, 0xf2f7ff, 0xe6f2ff, 0xdff6ff];

            for (let j = 0; j < leafSparkleIndices.length; j++) {
                const i = leafSparkleIndices[j];
                const ix = i * 3;

                spPos[j*3]   = s.array[ix];
                spPos[j*3+1] = s.array[ix+1];
                spPos[j*3+2] = s.array[ix+2];

                const c = new THREE.Color(sparklePalette[Math.floor(Math.random() * sparklePalette.length)]);
                baseCols[j*3]   = c.r;
                baseCols[j*3+1] = c.g;
                baseCols[j*3+2] = c.b;

                spCols[j*3]   = baseCols[j*3];
                spCols[j*3+1] = baseCols[j*3+1];
                spCols[j*3+2] = baseCols[j*3+2];

                phase[j] = Math.random() * Math.PI * 2;
                speed[j] = 3.5 + Math.random() * 6.5;
            }

            spGeo.setAttribute('position', new THREE.BufferAttribute(spPos, 3));
            spGeo.setAttribute('color', new THREE.BufferAttribute(spCols, 3));

            leafSparkleBaseCols = baseCols;
            leafSparkleCols = spGeo.attributes.color;
            leafSparklePhase = phase;
            leafSparkleSpeed = speed;

            leafSparkleMat = new THREE.PointsMaterial({
                size: 0.56,
                vertexColors: true,
                transparent: true,
                opacity: 0.0,
                depthWrite: false,
                depthTest: false,
                blending: THREE.AdditiveBlending
            });

            leafSparkles = new THREE.Points(spGeo, leafSparkleMat);
            leafSparkles.renderOrder = 9;
            mainGroup.add(leafSparkles);
        }

        function createTrunkGlow() {
            if (!trunkIndices.length) return;

            const baseGeo = particles.geometry;
            const s = baseGeo.attributes.tS;

            const tGeo = new THREE.BufferGeometry();
            const tPos = new Float32Array(trunkIndices.length * 3);
            const tCols = new Float32Array(trunkIndices.length * 3);

            for (let j = 0; j < trunkIndices.length; j++) {
                const i = trunkIndices[j];
                const ix = i * 3;

                tPos[j*3]   = s.array[ix];
                tPos[j*3+1] = s.array[ix+1];
                tPos[j*3+2] = s.array[ix+2];

                const y = tPos[j*3+1];
                const k = THREE.MathUtils.clamp((y + 5.2) / 2.2, 0, 1);
                const c = new THREE.Color().setHSL(0.08, 0.75, 0.25 + 0.35 * k);
                tCols[j*3] = c.r; tCols[j*3+1] = c.g; tCols[j*3+2] = c.b;
            }

            tGeo.setAttribute('position', new THREE.BufferAttribute(tPos, 3));
            tGeo.setAttribute('color', new THREE.BufferAttribute(tCols, 3));

            trunkMaterial = new THREE.PointsMaterial({
                size: 0.40,
                vertexColors: true,
                transparent: true,
                opacity: 0.65,
                depthWrite: false,
                depthTest: true,
                blending: THREE.AdditiveBlending
            });

            trunkParticles = new THREE.Points(tGeo, trunkMaterial);
            trunkParticles.renderOrder = 7;
            mainGroup.add(trunkParticles);
        }

        function createTrunkCoreGlow() {
            if (!trunkCoreIndices.length) return;

            const baseGeo = particles.geometry;
            const s = baseGeo.attributes.tS;

            const cGeo = new THREE.BufferGeometry();
            const cPos = new Float32Array(trunkCoreIndices.length * 3);
            const cCols = new Float32Array(trunkCoreIndices.length * 3);

            for (let j = 0; j < trunkCoreIndices.length; j++) {
                const i = trunkCoreIndices[j];
                const ix = i * 3;

                cPos[j*3]   = s.array[ix];
                cPos[j*3+1] = s.array[ix+1];
                cPos[j*3+2] = s.array[ix+2];

                const y = cPos[j*3+1];
                const k = THREE.MathUtils.clamp((y + 5.2) / 2.2, 0, 1);
                const c = new THREE.Color().setHSL(0.10, 0.95, 0.55 + 0.12 * k);
                cCols[j*3] = c.r; cCols[j*3+1] = c.g; cCols[j*3+2] = c.b;
            }

            cGeo.setAttribute('position', new THREE.BufferAttribute(cPos, 3));
            cGeo.setAttribute('color', new THREE.BufferAttribute(cCols, 3));

            trunkCoreMaterial = new THREE.PointsMaterial({
                size: 0.78,
                vertexColors: true,
                transparent: true,
                opacity: 0.92,
                depthWrite: false,
                depthTest: false,
                blending: THREE.AdditiveBlending
            });

            trunkCoreParticles = new THREE.Points(cGeo, trunkCoreMaterial);
            trunkCoreParticles.renderOrder = 8;
            mainGroup.add(trunkCoreParticles);
        }

        function createParticles() {
            lightIndices = [];
            leafSparkleIndices = [];
            trunkIndices = [];
            trunkCoreIndices = [];

            const LIGHT_RATIO = 0.06;
            const SPARKLE_RATIO = 0.05;

            const geo = new THREE.BufferGeometry();
            const pos = new Float32Array(PARTICLE_COUNT * 3),
                  tS = new Float32Array(PARTICLE_COUNT * 3),
                  tH = new Float32Array(PARTICLE_COUNT * 3),
                  tG = new Float32Array(PARTICLE_COUNT * 3),
                  cols = new Float32Array(PARTICLE_COUNT * 3);
            const palette = [0xf1c40f, 0x2ecc71, 0xffffff, 0xe74c3c, 0x111111];

            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const colorIdx = Math.floor(Math.random() * palette.length);
                const color = new THREE.Color(palette[colorIdx]);
                cols[i*3] = color.r; cols[i*3+1] = color.g; cols[i*3+2] = color.b;

                if (i < PARTICLE_COUNT * 0.92) {
                    const h = Math.random() * 8 - 4;
                    const rMax = ((4 - h) / 8) * 3.8;
                    const r = Math.sqrt(Math.random()) * rMax;
                    const a = Math.random() * Math.PI * 2;
                    tS[i*3] = Math.cos(a) * r; tS[i*3+1] = h + 1; tS[i*3+2] = Math.sin(a) * r;

                    if (Math.random() < LIGHT_RATIO) lightIndices.push(i);
                    else if (Math.random() < SPARKLE_RATIO) leafSparkleIndices.push(i);

                } else {
                    const hTrunk = Math.random() * 2 - 5.5;
                    const rTrunk = Math.random() * 0.6;
                    const aTrunk = Math.random() * Math.PI * 2;

                    tS[i*3] = Math.cos(aTrunk) * rTrunk;
                    tS[i*3+1] = hTrunk + 1;
                    tS[i*3+2] = Math.sin(aTrunk) * rTrunk;

                    cols[i*3] = 0.20; cols[i*3+1] = 0.12; cols[i*3+2] = 0.06;

                    trunkIndices.push(i);
                    if (rTrunk < 0.22) trunkCoreIndices.push(i);
                }

                const t = Math.random() * Math.PI * 2;
                const hX = 16 * Math.pow(Math.sin(t), 3), hY = 13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t);
                tH[i*3] = hX * 0.45; tH[i*3+1] = hY * 0.45; tH[i*3+2] = (Math.random()-0.5)*2;

                const branch = Math.floor(Math.random() * 4);
                const angle = Math.random() * Math.PI * 10;
                const dist = (Math.random() * 12) + (angle * 0.35);
                const noiseY = (Math.random() - 0.5) * 9;
                tG[i*3] = Math.cos(angle + (branch * Math.PI / 2)) * dist;
                tG[i*3+1] = noiseY * (1 - (dist/18));
                tG[i*3+2] = Math.sin(angle + (branch * Math.PI / 2)) * dist;
            }

            geo.setAttribute('position', new THREE.BufferAttribute(pos, 3));
            geo.setAttribute('tS', new THREE.BufferAttribute(tS, 3));
            geo.setAttribute('tH', new THREE.BufferAttribute(tH, 3));
            geo.setAttribute('tG', new THREE.BufferAttribute(tG, 3));
            geo.setAttribute('color', new THREE.BufferAttribute(cols, 3));

            particles = new THREE.Points(geo, new THREE.PointsMaterial({ size: 0.18, vertexColors: true, transparent: true, opacity: 0.85 }));
            mainGroup.add(particles);

            createLights();
            createLeafSparkles();
            createTrunkGlow();
            createTrunkCoreGlow();
        }

        function createUltimateSnowflake() {
            snowflakeGroup = new THREE.Group();

            const makeRadialTexture = (size, inner, outer) => {
                const c = document.createElement('canvas');
                c.width = c.height = size;
                const ctx = c.getContext('2d');

                const g = ctx.createRadialGradient(size/2, size/2, inner, size/2, size/2, outer);
                g.addColorStop(0.0, 'rgba(255,255,255,1)');
                g.addColorStop(0.35, 'rgba(255,255,255,0.85)');
                g.addColorStop(1.0, 'rgba(255,255,255,0)');

                ctx.fillStyle = g;
                ctx.fillRect(0, 0, size, size);

                const tex = new THREE.CanvasTexture(c);
                tex.needsUpdate = true;
                return tex;
            };

            const makeGlitterTexture = (size = 256) => {
                const c = document.createElement('canvas');
                c.width = c.height = size;
                const ctx = c.getContext('2d');
                const img = ctx.createImageData(size, size);

                for (let i = 0; i < img.data.length; i += 4) {
                    const r = Math.random();
                    let v;
                    if (r < 0.07) v = 255;
                    else if (r < 0.20) v = 220;
                    else v = 120 + Math.floor(Math.random() * 80);
                    img.data[i] = v; img.data[i+1] = v; img.data[i+2] = v; img.data[i+3] = 255;
                }
                ctx.putImageData(img, 0, 0);

                const tex = new THREE.CanvasTexture(c);
                tex.wrapS = tex.wrapT = THREE.RepeatWrapping;
                tex.repeat.set(3.6, 3.6);
                tex.needsUpdate = true;
                return tex;
            };

            const glowTex = makeRadialTexture(256, 0, 135);
            const sparkleTex = makeRadialTexture(128, 0, 42);
            const glitterTex = makeGlitterTexture(256);

            starMaterial = new THREE.MeshStandardMaterial({
                color: 0xFFD700,
                emissive: 0x5c4500,
                emissiveIntensity: 0.22,
                metalness: 0.82,
                roughness: 0.30,
                bumpMap: glitterTex,
                bumpScale: 0.14,
                roughnessMap: glitterTex,
                depthWrite: false
            });

            const makeStar2DPoints = (outerR, innerR) => {
                const pts = [];
                const step = Math.PI / 5;
                for (let i = 0; i < 10; i++) {
                    const r = (i % 2 === 0) ? outerR : innerR;
                    const a = i * step - Math.PI / 2;
                    pts.push({ x: Math.cos(a) * r, y: Math.sin(a) * r, isTip: (i % 2 === 0) });
                }
                return pts;
            };

            const buildOrnamentStarGeometry = () => {
                const pts = makeStar2DPoints(1.65, 0.72);

                const tipFrontZ  = 0.95;
                const tipBackZ   = -0.95;

                const innerFrontZ = 0.22;
                const innerBackZ  = -0.22;

                const positions = [];
                const indices = [];
                const frontIdx = [];
                const backIdx = [];

                for (let i = 0; i < pts.length; i++) {
                    const zF = pts[i].isTip ? tipFrontZ : innerFrontZ;
                    const zB = pts[i].isTip ? tipBackZ  : innerBackZ;

                    frontIdx[i] = positions.length / 3;
                    positions.push(pts[i].x, pts[i].y, zF);

                    backIdx[i] = positions.length / 3;
                    positions.push(pts[i].x, pts[i].y, zB);
                }

                const centerFront = positions.length / 3;
                positions.push(0, 0, 0.35);
                const centerBack = positions.length / 3;
                positions.push(0, 0, -0.35);

                const n = pts.length;

                for (let i = 0; i < n; i++) {
                    const a = frontIdx[i];
                    const b = frontIdx[(i + 1) % n];
                    indices.push(centerFront, a, b);
                }

                for (let i = 0; i < n; i++) {
                    const a = backIdx[i];
                    const b = backIdx[(i + 1) % n];
                    indices.push(centerBack, b, a);
                }

                for (let i = 0; i < n; i++) {
                    const f0 = frontIdx[i];
                    const f1 = frontIdx[(i + 1) % n];
                    const b0 = backIdx[i];
                    const b1 = backIdx[(i + 1) % n];

                    indices.push(f0, f1, b1);
                    indices.push(f0, b1, b0);
                }

                const geo = new THREE.BufferGeometry();
                geo.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
                geo.setIndex(indices);
                geo.computeVertexNormals();
                geo.center();
                return geo;
            };

            const starMesh = new THREE.Mesh(buildOrnamentStarGeometry(), starMaterial);
            starMesh.rotation.set(0, 0, 0);
            snowflakeGroup.add(starMesh);

            const glowMat = new THREE.SpriteMaterial({
                map: glowTex,
                transparent: true,
                opacity: 0.18,
                blending: THREE.AdditiveBlending,
                depthWrite: false
            });
            snowflakeGlow = new THREE.Sprite(glowMat);
            snowflakeGlow.scale.set(4.1, 4.1, 1);
            snowflakeGlow.position.set(0, 0, -1.2);
            snowflakeGroup.add(snowflakeGlow);

            snowflakeSparkles = [];
            const sparkleCount = 80;
            for (let i = 0; i < sparkleCount; i++) {
                const sm = new THREE.SpriteMaterial({
                    map: sparkleTex,
                    transparent: true,
                    opacity: 0.0,
                    blending: THREE.AdditiveBlending,
                    depthWrite: false
                });

                const sp = new THREE.Sprite(sm);
                const r = 1.85 * Math.sqrt(Math.random());
                const a = Math.random() * Math.PI * 2;
                const z = (Math.random() - 0.5) * 1.4;
                sp.position.set(Math.cos(a) * r, Math.sin(a) * r, z);

                const baseScale = 0.10 + Math.random() * 0.26;
                sp.scale.set(baseScale, baseScale, 1);

                snowflakeSparkles.push({
                    sprite: sp,
                    baseScale,
                    baseOpacity: 0.15 + Math.random() * 0.50,
                    phase: Math.random() * Math.PI * 2,
                    speed: 1.8 + Math.random() * 3.2
                });

                snowflakeGroup.add(sp);
            }

            snowflakeGroup.position.set(0, 5.35, 0);
            snowflakeGroup.scale.setScalar(0.78);
            snowflakeGroup.rotation.set(0, 0, 0);

            scene.add(snowflakeGroup);
        }

        // ====== HEART GESTURE (2 hands) helpers ======
        function _dist2(a, b) {
            const dx = a.x - b.x, dy = a.y - b.y;
            return Math.hypot(dx, dy);
        }

        function _palmSize(lm) {
            return _dist2(lm[0], lm[9]);
        }

        function _isTwoHandHeart(lmA, lmB) {
            const s = (_palmSize(lmA) + _palmSize(lmB)) * 0.5;
            if (!isFinite(s) || s < 1e-6) return false;

            const idxA = lmA[8], idxB = lmB[8];
            const thA  = lmA[4], thB  = lmB[4];

            const dIdx = _dist2(idxA, idxB);
            const dTh  = _dist2(thA,  thB);

            const idxAboveThumb = (idxA.y < thA.y) && (idxB.y < thB.y);

            const cA = { x: (idxA.x + thA.x) * 0.5, y: (idxA.y + thA.y) * 0.5 };
            const cB = { x: (idxB.x + thB.x) * 0.5, y: (idxB.y + thB.y) * 0.5 };
            const dC = Math.hypot(cA.x - cB.x, cA.y - cB.y);

            return (
                idxAboveThumb &&
                dIdx < 0.55 * s &&
                dTh  < 0.80 * s &&
                dC   < 1.25 * s
            );
        }
        // ====== END helpers ======

        // ====== OK GESTURE (thumb + index tạo vòng tròn) ======
        function _isOkGesture(lm) {
            const s = _palmSize(lm);
            if (!isFinite(s) || s < 1e-6) return false;

            const d = _dist2(lm[4], lm[8]); // thumb tip - index tip

            const upMiddle = lm[12].y < lm[10].y;
            const upRing   = lm[16].y < lm[14].y;
            const upPinky  = lm[20].y < lm[18].y;

            // ngưỡng 0.42 dễ bắt hơn; muốn khó hơn thì giảm về 0.35
            return (d < 0.42 * s) && upMiddle && upRing && upPinky;
        }
        // ====== END OK ======

        // ===== OK LOVE TEXT: typewriter =====
        function buildChars(el, text) {
            el.innerHTML = "";
            const frag = document.createDocumentFragment();

            for (const ch of text) {
                if (ch === " ") {
                    const sp = document.createElement("span");
                    sp.className = "ok-space";
                    sp.innerHTML = "&nbsp;";
                    frag.appendChild(sp);
                } else {
                    const s = document.createElement("span");
                    s.className = "ok-char";
                    s.textContent = ch;
                    frag.appendChild(s);
                }
            }
            el.appendChild(frag);
            return el.querySelectorAll(".ok-char, .ok-space");
        }

        function playOkLoveText() {
            const line1 = "Noel 2025 - 131 days with my baby";
            const line2 = "Thank you for staying by my side. We've gone through joys and sorrows together, and you still chose to stay—that's the greatest honor and the luckiest thing in my life, love you";

            const chars1 = buildChars(okLine1El, line1);
            const chars2 = buildChars(okLine2El, line2);

            if (okTextTL) okTextTL.kill();

            okTextTL = gsap.timeline({ paused: true });
            okTextTL
                .set(okLoveEl, { display: "block" })
                .to(okLoveEl, { opacity: 1, duration: 0.22, ease: "power2.out" })
                .to("#ok-love .ok-line", { backgroundPosition: "260% 50%", duration: 2.2, ease: "none" }, 0)
                .to(chars1, { opacity: 1, y: 0, duration: 0.06, ease: "power2.out", stagger: 0.03 }, 0.10)
                .to(chars2, { opacity: 1, y: 0, duration: 0.06, ease: "power2.out", stagger: 0.018 }, ">0.18");

            okTextTL.play(0);
        }
        // ===== END OK LOVE TEXT =====

        async function setupMediaPipe() {
            videoElement = document.getElementById('webcam');
            handTracker = new Hands({ locateFile: (f) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${f}` });

            // 2 tay để bắt “heart bằng 2 tay”
            handTracker.setOptions({ maxNumHands: 2, modelComplexity: 1 });

            handTracker.onResults(res => {
                tHeart = 0;
                tGalaxy = 0;
                tOk = 0;

                const hands = res.multiHandLandmarks;

                // 1) HEART: ưu tiên cao nhất (2 tay chụm)
                if (hands && hands.length >= 2) {
                    if (_isTwoHandHeart(hands[0], hands[1])) {
                        tHeart = 1;
                        return;
                    }
                }

                // 2) OK: nếu bất kỳ tay nào làm OK => bật OK
                if (hands && hands.length) {
                    for (let i = 0; i < hands.length; i++) {
                        if (_isOkGesture(hands[i])) {
                            tOk = 1;
                            return;
                        }
                    }
                }

                // 3) GALAXY: giữ nguyên 1 tay giơ 3 ngón
                if (hands && hands[0]) {
                    const lm = hands[0];
                    const up1 = lm[8].y < lm[6].y;
                    const up2 = lm[12].y < lm[10].y;
                    const up3 = lm[16].y < lm[14].y;

                    if (up1 && up2 && up3) {
                        tGalaxy = 1;
                        return;
                    }
                }
            });

            new Camera(videoElement, {
                onFrame: async () => await handTracker.send({ image: videoElement }),
                width: 640,
                height: 480
            }).start();
        }

        function render() {
            const nowMs = performance.now();
            renderSnow(nowMs);

            const tt = nowMs * 0.001;

            fHeart  = THREE.MathUtils.lerp(fHeart,  tHeart,  0.08);
            fGalaxy = THREE.MathUtils.lerp(fGalaxy, tGalaxy, 0.08);
            fOk     = THREE.MathUtils.lerp(fOk,     tOk,     0.12);

            // Tree chỉ khi KHÔNG heart, KHÔNG galaxy, KHÔNG ok
            const isTree = (fHeart < 0.1 && fGalaxy < 0.1 && fOk < 0.1);

            if (greetingEl) greetingEl.style.display = isTree ? 'block' : 'none';

            // OK LOVE TEXT show/hide + typewriter
            const okOn  = (fOk > 0.78);
            const okOff = (fOk < 0.25);

            if (okOn && !okTextShown) {
                okTextShown = true;
                playOkLoveText();
            }
            if (okOff && okTextShown) {
                okTextShown = false;
                gsap.to(okLoveEl, {
                    opacity: 0,
                    duration: 0.18,
                    onComplete: () => { okLoveEl.style.display = "none"; }
                });
            }

            mainGroup.rotation.y += 0.008;

            const p = particles.geometry.attributes.position, s = particles.geometry.attributes.tS, h = particles.geometry.attributes.tH, g = particles.geometry.attributes.tG;
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const ix=i*3, iy=i*3+1, iz=i*3+2;
                let tx = s.array[ix], ty = s.array[iy], tz = s.array[iz];

                tx = THREE.MathUtils.lerp(tx, h.array[ix], fHeart);
                ty = THREE.MathUtils.lerp(ty, h.array[iy], fHeart);
                tz = THREE.MathUtils.lerp(tz, h.array[iz], fHeart);

                tx = THREE.MathUtils.lerp(tx, g.array[ix], fGalaxy);
                ty = THREE.MathUtils.lerp(ty, g.array[iy], fGalaxy);
                tz = THREE.MathUtils.lerp(tz, g.array[iz], fGalaxy);

                if (isTree) ty += TREE_Y_OFFSET;

                p.array[ix] = tx; p.array[iy] = ty; p.array[iz] = tz;
            }
            p.needsUpdate = true;

            if (lightParticles) {
                lightParticles.visible = isTree;
                const lp = lightParticles.geometry.attributes.position;
                for (let j = 0; j < lightIndices.length; j++) {
                    const i = lightIndices[j];
                    const ix = i * 3;
                    lp.array[j*3]   = p.array[ix];
                    lp.array[j*3+1] = p.array[ix+1];
                    lp.array[j*3+2] = p.array[ix+2];
                }
                lp.needsUpdate = true;

                lightMaterial.opacity = 0.55 + 0.35 * (0.5 + 0.5 * Math.sin(tt * 6.0));
                lightMaterial.size = 0.36 + 0.10 * (0.5 + 0.5 * Math.sin(tt * 5.2));
            }

            if (leafSparkles) {
                leafSparkles.visible = isTree;

                const spPos = leafSparkles.geometry.attributes.position;
                for (let j = 0; j < leafSparkleIndices.length; j++) {
                    const i = leafSparkleIndices[j];
                    const ix = i * 3;
                    spPos.array[j*3]   = p.array[ix];
                    spPos.array[j*3+1] = p.array[ix+1];
                    spPos.array[j*3+2] = p.array[ix+2];
                }
                spPos.needsUpdate = true;

                if (leafSparkleCols && leafSparkleBaseCols && leafSparklePhase && leafSparkleSpeed) {
                    const carr = leafSparkleCols.array;
                    for (let j = 0; j < leafSparkleIndices.length; j++) {
                        const tw = 0.10 + 0.90 * (0.5 + 0.5 * Math.sin(tt * leafSparkleSpeed[j] + leafSparklePhase[j]));
                        const boost = tw * tw;
                        carr[j*3]   = leafSparkleBaseCols[j*3]   * (0.25 + 0.90 * boost);
                        carr[j*3+1] = leafSparkleBaseCols[j*3+1] * (0.25 + 0.90 * boost);
                        carr[j*3+2] = leafSparkleBaseCols[j*3+2] * (0.25 + 0.90 * boost);
                    }
                    leafSparkleCols.needsUpdate = true;
                }

                leafSparkleMat.opacity = 0.10 + 0.35 * (0.5 + 0.5 * Math.sin(tt * 1.8));
                leafSparkleMat.size = 0.52 + 0.12 * (0.5 + 0.5 * Math.sin(tt * 2.2));
            }

            if (trunkParticles) {
                trunkParticles.visible = isTree;
                trunkMaterial.opacity = 0.55 + 0.15 * (0.5 + 0.5 * Math.sin(tt * 2.4));
            }

            if (trunkCoreParticles) {
                trunkCoreParticles.visible = isTree;
                trunkCoreMaterial.opacity = 0.78 + 0.22 * (0.5 + 0.5 * Math.sin(tt * 3.6));
                trunkCoreMaterial.size = 0.72 + 0.14 * (0.5 + 0.5 * Math.sin(tt * 2.8));
            }

            photoPairs.forEach(pair => {
                const pos = new THREE.Vector3(0,0,0);
                pos.lerp(pair.group.userData.posHeart, fHeart);
                pos.lerp(pair.group.userData.posGalaxy, fGalaxy);
                pair.group.position.copy(pos);

                pair.group.rotation.y = -mainGroup.rotation.y;

                pair.photoMat.opacity = Math.max(fHeart, fGalaxy);
                pair.borderMat.opacity = Math.max(fHeart, fGalaxy);
            });

            if (snowflakeGroup) {
                snowflakeGroup.visible = isTree;
                if (isTree) snowflakeGroup.position.y = 5.35 + TREE_Y_OFFSET;

                if (isTree) {
                    if (starMaterial) {
                        starMaterial.emissiveIntensity = 0.18 + 0.12 * (0.5 + 0.5 * Math.sin(tt * 2.4));
                    }

                    if (snowflakeGlow) {
                        const pGlow = 0.5 + 0.5 * Math.sin(tt * 1.7);
                        snowflakeGlow.material.opacity = 0.10 + 0.12 * pGlow;
                        const sGlow = 3.8 + 0.55 * pGlow;
                        snowflakeGlow.scale.set(sGlow, sGlow, 1);
                    }

                    for (let i = 0; i < snowflakeSparkles.length; i++) {
                        const sp = snowflakeSparkles[i];
                        const tw = 0.5 + 0.5 * Math.sin(tt * sp.speed + sp.phase);
                        sp.sprite.material.opacity = sp.baseOpacity * (0.10 + 0.90 * tw);
                        const sc = sp.baseScale * (0.65 + 0.85 * tw);
                        sp.sprite.scale.set(sc, sc, 1);
                    }
                }
            }

            renderer.render(scene, camera);
        }
    </script>
</body>
</html>
