<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Core Hand Gestures - Xmas Tree with Music</title>
    
    <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
    <script src="https://www.youtube.com/iframe_api"></script>

    <style>
        body { margin: 0; overflow: hidden; background: #000; }
        #bg-image { position: fixed; inset: 0; background: url('https://images.unsplash.com/photo-1543589077-47d81606c1bf?q=80&w=2070') center/cover; filter: brightness(0.1); z-index: -1; }
        #start-overlay { position: fixed; inset: 0; background: rgba(0,0,0,0.9); display: flex; align-items: center; justify-content: center; z-index: 200; }
        #start-btn { padding: 15px 40px; border: 1px solid #fff; background: none; color: #fff; cursor: pointer; font-family: sans-serif; letter-spacing: 2px; }
        #video-container { position: absolute; bottom: 20px; right: 20px; width: 160px; height: 120px; border-radius: 8px; overflow: hidden; transform: scaleX(-1); border: 1px solid #333; }
        video { width: 100%; height: 100%; object-fit: cover; }
        /* Ẩn trình phát nhạc */
        #yt-player-container { position: absolute; top: -1000px; left: -1000px; }
    </style>
</head>
<body>

    <div id="bg-image"></div>
    <div id="yt-player-container"><div id="player"></div></div>
    
    <div id="start-overlay"><button id="start-btn">BẮT ĐẦU</button></div>
    <div id="video-container"><video id="webcam" autoplay playsinline></video></div>

    <script>
        const PARTICLE_COUNT = 30000;
        let scene, camera, renderer, particles, snowflake, ytPlayer;
        let handTracker, videoElement;
        let assemblyFactor = 0, targetAssembly = 0;

        // Khởi tạo trình phát nhạc
        function onYouTubeIframeAPIReady() {
            ytPlayer = new YT.Player('player', {
                height: '0', width: '0', videoId: '6ag__ntUafU',
                playerVars: { 'autoplay': 0, 'controls': 0, 'loop': 1, 'playlist': '6ag__ntUafU' }
            });
        }

        document.getElementById('start-btn').onclick = function() {
            document.getElementById('start-overlay').style.display = 'none';
            // Phát nhạc khi nhấn bắt đầu
            if (ytPlayer && ytPlayer.playVideo) ytPlayer.playVideo();
            init();
        };

        function createCircleTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 64; canvas.height = 64;
            const ctx = canvas.getContext('2d');
            ctx.beginPath(); ctx.arc(32, 32, 30, 0, Math.PI * 2);
            ctx.fillStyle = '#ffffff'; ctx.fill();
            return new THREE.CanvasTexture(canvas);
        }

        async function init() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 7;

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);
            
            createParticles();
            createSnowflake();
            await setupMediaPipe();
            gsap.ticker.add(render);
        }

        function createParticles() {
            const geo = new THREE.BufferGeometry();
            const pos = new Float32Array(PARTICLE_COUNT * 3), tar = new Float32Array(PARTICLE_COUNT * 3);
            const chos = new Float32Array(PARTICLE_COUNT * 3), cols = new Float32Array(PARTICLE_COUNT * 3);
            const palette = [0xf1c40f, 0x2ecc71, 0xffffff, 0xe74c3c, 0x111111];

            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const h = Math.random() * 6 - 3; 
                const radTree = ((3 - h) / 6) * 2.3; 
                const angTree = Math.random() * Math.PI * 2;
                tar[i*3] = Math.cos(angTree) * radTree; tar[i*3+1] = h; tar[i*3+2] = Math.sin(angTree) * radTree;

                const angle = Math.random() * Math.PI * 2;
                const radius = Math.pow(Math.random(), 0.5) * 12;
                chos[i*3] = Math.cos(angle) * radius; chos[i*3+1] = (Math.random() - 0.5) * 6; chos[i*3+2] = Math.sin(angle) * radius;

                const c = new THREE.Color(palette[Math.floor(Math.random() * palette.length)]);
                cols[i*3] = c.r; cols[i*3+1] = c.g; cols[i*3+2] = c.b;
            }

            geo.setAttribute('position', new THREE.BufferAttribute(pos, 3));
            geo.setAttribute('target', new THREE.BufferAttribute(tar, 3));
            geo.setAttribute('chaos', new THREE.BufferAttribute(chos, 3));
            geo.setAttribute('color', new THREE.BufferAttribute(cols, 3));
            
            particles = new THREE.Points(geo, new THREE.PointsMaterial({ 
                size: 0.04, vertexColors: true, map: createCircleTexture(), transparent: true, opacity: 1, alphaTest: 0.05
            }));
            scene.add(particles);
        }

        function createSnowflake() {
            snowflake = new THREE.Group();
            const mat = new THREE.MeshBasicMaterial({ color: 0xffffff, side: THREE.DoubleSide, transparent: true, opacity: 0 });
            const createBranch = () => {
                const shape = new THREE.Shape();
                shape.moveTo(0,0); shape.lineTo(0.04,0.1); shape.lineTo(0.01,0.7); shape.lineTo(0,0.75); shape.lineTo(-0.01,0.7); shape.lineTo(-0.04,0.1);
                const m = new THREE.Mesh(new THREE.ShapeGeometry(shape), mat);
                for(let i=0; i<3; i++) {
                    const s = m.clone(); s.scale.set(0.35,0.35,1); s.position.set(0,0.2+i*0.2,0); s.rotation.z=Math.PI/4;
                    const s2 = s.clone(); s2.rotation.z=-Math.PI/4; m.add(s,s2);
                }
                return m;
            };
            for (let i = 0; i < 6; i++) { const b = createBranch(); b.rotation.z = (i*Math.PI*2)/6; snowflake.add(b); }
            snowflake.position.y = 3.3; scene.add(snowflake);
        }

        async function setupMediaPipe() {
            videoElement = document.getElementById('webcam');
            handTracker = new Hands({ locateFile: (f) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${f}` });
            handTracker.setOptions({ maxNumHands: 1, modelComplexity: 1 });
            handTracker.onResults(results => {
                if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                    const lm = results.multiHandLandmarks[0];
                    targetAssembly = (lm[8].y > lm[6].y && lm[12].y > lm[10].y) ? 1 : 0;
                } else { targetAssembly = 0; }
            });
            new Camera(videoElement, { onFrame: async () => await handTracker.send({ image: videoElement }), width: 640, height: 480 }).start();
        }

        function render() {
            assemblyFactor = THREE.MathUtils.lerp(assemblyFactor, targetAssembly, 0.07);
            
            // Điều chỉnh âm lượng theo trạng thái cây (Nắm tay = 80%, Xòe tay = 20%)
            if(ytPlayer && ytPlayer.setVolume) {
                ytPlayer.setVolume(20 + assemblyFactor * 60);
            }

            const p = particles.geometry.attributes.position, t = particles.geometry.attributes.target, c = particles.geometry.attributes.chaos;
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const ix=i*3, iy=i*3+1, iz=i*3+2;
                p.array[ix] = THREE.MathUtils.lerp(c.array[ix], t.array[ix], assemblyFactor);
                p.array[iy] = THREE.MathUtils.lerp(c.array[iy], t.array[iy], assemblyFactor);
                p.array[iz] = THREE.MathUtils.